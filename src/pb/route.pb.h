// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: route.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_route_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_route_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_route_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_route_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
void AddDescriptors_route_2eproto();
namespace frrpc {
namespace route {
class ChannelServiceRegister;
class ChannelServiceRegisterDefaultTypeInternal;
extern ChannelServiceRegisterDefaultTypeInternal _ChannelServiceRegister_default_instance_;
class NotifyType_Disconnect;
class NotifyType_DisconnectDefaultTypeInternal;
extern NotifyType_DisconnectDefaultTypeInternal _NotifyType_Disconnect_default_instance_;
class RouteCmdRequest;
class RouteCmdRequestDefaultTypeInternal;
extern RouteCmdRequestDefaultTypeInternal _RouteCmdRequest_default_instance_;
class RouteCmdResponse;
class RouteCmdResponseDefaultTypeInternal;
extern RouteCmdResponseDefaultTypeInternal _RouteCmdResponse_default_instance_;
class RouteNetInfo;
class RouteNetInfoDefaultTypeInternal;
extern RouteNetInfoDefaultTypeInternal _RouteNetInfo_default_instance_;
class RouteNotify;
class RouteNotifyDefaultTypeInternal;
extern RouteNotifyDefaultTypeInternal _RouteNotify_default_instance_;
class RouteServiceInfo;
class RouteServiceInfoDefaultTypeInternal;
extern RouteServiceInfoDefaultTypeInternal _RouteServiceInfo_default_instance_;
class ServerDisconnectChannel;
class ServerDisconnectChannelDefaultTypeInternal;
extern ServerDisconnectChannelDefaultTypeInternal _ServerDisconnectChannel_default_instance_;
}  // namespace route
}  // namespace frrpc
PROTOBUF_NAMESPACE_OPEN
template<> ::frrpc::route::ChannelServiceRegister* Arena::CreateMaybeMessage<::frrpc::route::ChannelServiceRegister>(Arena*);
template<> ::frrpc::route::NotifyType_Disconnect* Arena::CreateMaybeMessage<::frrpc::route::NotifyType_Disconnect>(Arena*);
template<> ::frrpc::route::RouteCmdRequest* Arena::CreateMaybeMessage<::frrpc::route::RouteCmdRequest>(Arena*);
template<> ::frrpc::route::RouteCmdResponse* Arena::CreateMaybeMessage<::frrpc::route::RouteCmdResponse>(Arena*);
template<> ::frrpc::route::RouteNetInfo* Arena::CreateMaybeMessage<::frrpc::route::RouteNetInfo>(Arena*);
template<> ::frrpc::route::RouteNotify* Arena::CreateMaybeMessage<::frrpc::route::RouteNotify>(Arena*);
template<> ::frrpc::route::RouteServiceInfo* Arena::CreateMaybeMessage<::frrpc::route::RouteServiceInfo>(Arena*);
template<> ::frrpc::route::ServerDisconnectChannel* Arena::CreateMaybeMessage<::frrpc::route::ServerDisconnectChannel>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace frrpc {
namespace route {

enum eRouteCmd {
  eRouteCmd_Tmp = 0,
  eRouteCmd_Channel_ServiceRegister = 1,
  eRouteCmd_Server_DisconnectChannel = 2,
  eRouteCmd_Server_ServiceRegister = 3,
  eRouteCmd_Server_ServiceCancel = 4,
  eRouteCmd_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  eRouteCmd_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool eRouteCmd_IsValid(int value);
constexpr eRouteCmd eRouteCmd_MIN = eRouteCmd_Tmp;
constexpr eRouteCmd eRouteCmd_MAX = eRouteCmd_Server_ServiceCancel;
constexpr int eRouteCmd_ARRAYSIZE = eRouteCmd_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* eRouteCmd_descriptor();
inline const std::string& eRouteCmd_Name(eRouteCmd value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    eRouteCmd_descriptor(), value);
}
inline bool eRouteCmd_Parse(
    const std::string& name, eRouteCmd* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<eRouteCmd>(
    eRouteCmd_descriptor(), name, value);
}
enum eRouteNotifyType {
  eRouteNotifyType_Tmp = 0,
  eRouteNotifyType_Disconnect = 1,
  eRouteNotifyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  eRouteNotifyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool eRouteNotifyType_IsValid(int value);
constexpr eRouteNotifyType eRouteNotifyType_MIN = eRouteNotifyType_Tmp;
constexpr eRouteNotifyType eRouteNotifyType_MAX = eRouteNotifyType_Disconnect;
constexpr int eRouteNotifyType_ARRAYSIZE = eRouteNotifyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* eRouteNotifyType_descriptor();
inline const std::string& eRouteNotifyType_Name(eRouteNotifyType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    eRouteNotifyType_descriptor(), value);
}
inline bool eRouteNotifyType_Parse(
    const std::string& name, eRouteNotifyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<eRouteNotifyType>(
    eRouteNotifyType_descriptor(), name, value);
}
// ===================================================================

class RouteNetInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frrpc.route.RouteNetInfo) */ {
 public:
  RouteNetInfo();
  virtual ~RouteNetInfo();

  RouteNetInfo(const RouteNetInfo& from);
  RouteNetInfo(RouteNetInfo&& from) noexcept
    : RouteNetInfo() {
    *this = ::std::move(from);
  }

  inline RouteNetInfo& operator=(const RouteNetInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteNetInfo& operator=(RouteNetInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RouteNetInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteNetInfo* internal_default_instance() {
    return reinterpret_cast<const RouteNetInfo*>(
               &_RouteNetInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RouteNetInfo* other);
  friend void swap(RouteNetInfo& a, RouteNetInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteNetInfo* New() const final {
    return CreateMaybeMessage<RouteNetInfo>(nullptr);
  }

  RouteNetInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteNetInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RouteNetInfo& from);
  void MergeFrom(const RouteNetInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteNetInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frrpc.route.RouteNetInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 target_sockets = 3;
  int target_sockets_size() const;
  void clear_target_sockets();
  static const int kTargetSocketsFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 target_sockets(int index) const;
  void set_target_sockets(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_target_sockets(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      target_sockets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_target_sockets();

  // string service_name = 2;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 2;
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);

  // bool is_channel_packet = 1;
  void clear_is_channel_packet();
  static const int kIsChannelPacketFieldNumber = 1;
  bool is_channel_packet() const;
  void set_is_channel_packet(bool value);

  // int32 source_socket = 4;
  void clear_source_socket();
  static const int kSourceSocketFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 source_socket() const;
  void set_source_socket(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:frrpc.route.RouteNetInfo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > target_sockets_;
  mutable std::atomic<int> _target_sockets_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  bool is_channel_packet_;
  ::PROTOBUF_NAMESPACE_ID::int32 source_socket_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RouteCmdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frrpc.route.RouteCmdRequest) */ {
 public:
  RouteCmdRequest();
  virtual ~RouteCmdRequest();

  RouteCmdRequest(const RouteCmdRequest& from);
  RouteCmdRequest(RouteCmdRequest&& from) noexcept
    : RouteCmdRequest() {
    *this = ::std::move(from);
  }

  inline RouteCmdRequest& operator=(const RouteCmdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteCmdRequest& operator=(RouteCmdRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RouteCmdRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteCmdRequest* internal_default_instance() {
    return reinterpret_cast<const RouteCmdRequest*>(
               &_RouteCmdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RouteCmdRequest* other);
  friend void swap(RouteCmdRequest& a, RouteCmdRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteCmdRequest* New() const final {
    return CreateMaybeMessage<RouteCmdRequest>(nullptr);
  }

  RouteCmdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteCmdRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RouteCmdRequest& from);
  void MergeFrom(const RouteCmdRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteCmdRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frrpc.route.RouteCmdRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes request_binary = 2;
  void clear_request_binary();
  static const int kRequestBinaryFieldNumber = 2;
  const std::string& request_binary() const;
  void set_request_binary(const std::string& value);
  void set_request_binary(std::string&& value);
  void set_request_binary(const char* value);
  void set_request_binary(const void* value, size_t size);
  std::string* mutable_request_binary();
  std::string* release_request_binary();
  void set_allocated_request_binary(std::string* request_binary);

  // .frrpc.route.eRouteCmd cmd = 1;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::frrpc::route::eRouteCmd cmd() const;
  void set_cmd(::frrpc::route::eRouteCmd value);

  // @@protoc_insertion_point(class_scope:frrpc.route.RouteCmdRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_binary_;
  int cmd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RouteCmdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frrpc.route.RouteCmdResponse) */ {
 public:
  RouteCmdResponse();
  virtual ~RouteCmdResponse();

  RouteCmdResponse(const RouteCmdResponse& from);
  RouteCmdResponse(RouteCmdResponse&& from) noexcept
    : RouteCmdResponse() {
    *this = ::std::move(from);
  }

  inline RouteCmdResponse& operator=(const RouteCmdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteCmdResponse& operator=(RouteCmdResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RouteCmdResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteCmdResponse* internal_default_instance() {
    return reinterpret_cast<const RouteCmdResponse*>(
               &_RouteCmdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RouteCmdResponse* other);
  friend void swap(RouteCmdResponse& a, RouteCmdResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteCmdResponse* New() const final {
    return CreateMaybeMessage<RouteCmdResponse>(nullptr);
  }

  RouteCmdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteCmdResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RouteCmdResponse& from);
  void MergeFrom(const RouteCmdResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteCmdResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frrpc.route.RouteCmdResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .frrpc.route.eRouteCmd cmd = 1;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::frrpc::route::eRouteCmd cmd() const;
  void set_cmd(::frrpc::route::eRouteCmd value);

  // @@protoc_insertion_point(class_scope:frrpc.route.RouteCmdResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int cmd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class ChannelServiceRegister final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frrpc.route.ChannelServiceRegister) */ {
 public:
  ChannelServiceRegister();
  virtual ~ChannelServiceRegister();

  ChannelServiceRegister(const ChannelServiceRegister& from);
  ChannelServiceRegister(ChannelServiceRegister&& from) noexcept
    : ChannelServiceRegister() {
    *this = ::std::move(from);
  }

  inline ChannelServiceRegister& operator=(const ChannelServiceRegister& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelServiceRegister& operator=(ChannelServiceRegister&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChannelServiceRegister& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelServiceRegister* internal_default_instance() {
    return reinterpret_cast<const ChannelServiceRegister*>(
               &_ChannelServiceRegister_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ChannelServiceRegister* other);
  friend void swap(ChannelServiceRegister& a, ChannelServiceRegister& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChannelServiceRegister* New() const final {
    return CreateMaybeMessage<ChannelServiceRegister>(nullptr);
  }

  ChannelServiceRegister* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelServiceRegister>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelServiceRegister& from);
  void MergeFrom(const ChannelServiceRegister& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelServiceRegister* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frrpc.route.ChannelServiceRegister";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_name = 1;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);

  // string service_addr = 2;
  void clear_service_addr();
  static const int kServiceAddrFieldNumber = 2;
  const std::string& service_addr() const;
  void set_service_addr(const std::string& value);
  void set_service_addr(std::string&& value);
  void set_service_addr(const char* value);
  void set_service_addr(const char* value, size_t size);
  std::string* mutable_service_addr();
  std::string* release_service_addr();
  void set_allocated_service_addr(std::string* service_addr);

  // @@protoc_insertion_point(class_scope:frrpc.route.ChannelServiceRegister)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_addr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class ServerDisconnectChannel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frrpc.route.ServerDisconnectChannel) */ {
 public:
  ServerDisconnectChannel();
  virtual ~ServerDisconnectChannel();

  ServerDisconnectChannel(const ServerDisconnectChannel& from);
  ServerDisconnectChannel(ServerDisconnectChannel&& from) noexcept
    : ServerDisconnectChannel() {
    *this = ::std::move(from);
  }

  inline ServerDisconnectChannel& operator=(const ServerDisconnectChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerDisconnectChannel& operator=(ServerDisconnectChannel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ServerDisconnectChannel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerDisconnectChannel* internal_default_instance() {
    return reinterpret_cast<const ServerDisconnectChannel*>(
               &_ServerDisconnectChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ServerDisconnectChannel* other);
  friend void swap(ServerDisconnectChannel& a, ServerDisconnectChannel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerDisconnectChannel* New() const final {
    return CreateMaybeMessage<ServerDisconnectChannel>(nullptr);
  }

  ServerDisconnectChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerDisconnectChannel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerDisconnectChannel& from);
  void MergeFrom(const ServerDisconnectChannel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerDisconnectChannel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frrpc.route.ServerDisconnectChannel";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 channel_socket = 1;
  int channel_socket_size() const;
  void clear_channel_socket();
  static const int kChannelSocketFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 channel_socket(int index) const;
  void set_channel_socket(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_channel_socket(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      channel_socket() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_channel_socket();

  // @@protoc_insertion_point(class_scope:frrpc.route.ServerDisconnectChannel)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > channel_socket_;
  mutable std::atomic<int> _channel_socket_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RouteServiceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frrpc.route.RouteServiceInfo) */ {
 public:
  RouteServiceInfo();
  virtual ~RouteServiceInfo();

  RouteServiceInfo(const RouteServiceInfo& from);
  RouteServiceInfo(RouteServiceInfo&& from) noexcept
    : RouteServiceInfo() {
    *this = ::std::move(from);
  }

  inline RouteServiceInfo& operator=(const RouteServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteServiceInfo& operator=(RouteServiceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RouteServiceInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteServiceInfo* internal_default_instance() {
    return reinterpret_cast<const RouteServiceInfo*>(
               &_RouteServiceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RouteServiceInfo* other);
  friend void swap(RouteServiceInfo& a, RouteServiceInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteServiceInfo* New() const final {
    return CreateMaybeMessage<RouteServiceInfo>(nullptr);
  }

  RouteServiceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteServiceInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RouteServiceInfo& from);
  void MergeFrom(const RouteServiceInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteServiceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frrpc.route.RouteServiceInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string addr = 2;
  void clear_addr();
  static const int kAddrFieldNumber = 2;
  const std::string& addr() const;
  void set_addr(const std::string& value);
  void set_addr(std::string&& value);
  void set_addr(const char* value);
  void set_addr(const char* value, size_t size);
  std::string* mutable_addr();
  std::string* release_addr();
  void set_allocated_addr(std::string* addr);

  // @@protoc_insertion_point(class_scope:frrpc.route.RouteServiceInfo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RouteNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frrpc.route.RouteNotify) */ {
 public:
  RouteNotify();
  virtual ~RouteNotify();

  RouteNotify(const RouteNotify& from);
  RouteNotify(RouteNotify&& from) noexcept
    : RouteNotify() {
    *this = ::std::move(from);
  }

  inline RouteNotify& operator=(const RouteNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteNotify& operator=(RouteNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RouteNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteNotify* internal_default_instance() {
    return reinterpret_cast<const RouteNotify*>(
               &_RouteNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RouteNotify* other);
  friend void swap(RouteNotify& a, RouteNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteNotify* New() const final {
    return CreateMaybeMessage<RouteNotify>(nullptr);
  }

  RouteNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteNotify>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RouteNotify& from);
  void MergeFrom(const RouteNotify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteNotify* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frrpc.route.RouteNotify";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);

  // .frrpc.route.eRouteNotifyType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::frrpc::route::eRouteNotifyType type() const;
  void set_type(::frrpc::route::eRouteNotifyType value);

  // @@protoc_insertion_point(class_scope:frrpc.route.RouteNotify)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class NotifyType_Disconnect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frrpc.route.NotifyType_Disconnect) */ {
 public:
  NotifyType_Disconnect();
  virtual ~NotifyType_Disconnect();

  NotifyType_Disconnect(const NotifyType_Disconnect& from);
  NotifyType_Disconnect(NotifyType_Disconnect&& from) noexcept
    : NotifyType_Disconnect() {
    *this = ::std::move(from);
  }

  inline NotifyType_Disconnect& operator=(const NotifyType_Disconnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyType_Disconnect& operator=(NotifyType_Disconnect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NotifyType_Disconnect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NotifyType_Disconnect* internal_default_instance() {
    return reinterpret_cast<const NotifyType_Disconnect*>(
               &_NotifyType_Disconnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(NotifyType_Disconnect* other);
  friend void swap(NotifyType_Disconnect& a, NotifyType_Disconnect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NotifyType_Disconnect* New() const final {
    return CreateMaybeMessage<NotifyType_Disconnect>(nullptr);
  }

  NotifyType_Disconnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NotifyType_Disconnect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NotifyType_Disconnect& from);
  void MergeFrom(const NotifyType_Disconnect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyType_Disconnect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frrpc.route.NotifyType_Disconnect";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 socket = 1;
  void clear_socket();
  static const int kSocketFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 socket() const;
  void set_socket(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:frrpc.route.NotifyType_Disconnect)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 socket_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RouteNetInfo

// bool is_channel_packet = 1;
inline void RouteNetInfo::clear_is_channel_packet() {
  is_channel_packet_ = false;
}
inline bool RouteNetInfo::is_channel_packet() const {
  // @@protoc_insertion_point(field_get:frrpc.route.RouteNetInfo.is_channel_packet)
  return is_channel_packet_;
}
inline void RouteNetInfo::set_is_channel_packet(bool value) {
  
  is_channel_packet_ = value;
  // @@protoc_insertion_point(field_set:frrpc.route.RouteNetInfo.is_channel_packet)
}

// string service_name = 2;
inline void RouteNetInfo::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RouteNetInfo::service_name() const {
  // @@protoc_insertion_point(field_get:frrpc.route.RouteNetInfo.service_name)
  return service_name_.GetNoArena();
}
inline void RouteNetInfo::set_service_name(const std::string& value) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:frrpc.route.RouteNetInfo.service_name)
}
inline void RouteNetInfo::set_service_name(std::string&& value) {
  
  service_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:frrpc.route.RouteNetInfo.service_name)
}
inline void RouteNetInfo::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:frrpc.route.RouteNetInfo.service_name)
}
inline void RouteNetInfo::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:frrpc.route.RouteNetInfo.service_name)
}
inline std::string* RouteNetInfo::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:frrpc.route.RouteNetInfo.service_name)
  return service_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RouteNetInfo::release_service_name() {
  // @@protoc_insertion_point(field_release:frrpc.route.RouteNetInfo.service_name)
  
  return service_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RouteNetInfo::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:frrpc.route.RouteNetInfo.service_name)
}

// repeated int32 target_sockets = 3;
inline int RouteNetInfo::target_sockets_size() const {
  return target_sockets_.size();
}
inline void RouteNetInfo::clear_target_sockets() {
  target_sockets_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RouteNetInfo::target_sockets(int index) const {
  // @@protoc_insertion_point(field_get:frrpc.route.RouteNetInfo.target_sockets)
  return target_sockets_.Get(index);
}
inline void RouteNetInfo::set_target_sockets(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  target_sockets_.Set(index, value);
  // @@protoc_insertion_point(field_set:frrpc.route.RouteNetInfo.target_sockets)
}
inline void RouteNetInfo::add_target_sockets(::PROTOBUF_NAMESPACE_ID::int32 value) {
  target_sockets_.Add(value);
  // @@protoc_insertion_point(field_add:frrpc.route.RouteNetInfo.target_sockets)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
RouteNetInfo::target_sockets() const {
  // @@protoc_insertion_point(field_list:frrpc.route.RouteNetInfo.target_sockets)
  return target_sockets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
RouteNetInfo::mutable_target_sockets() {
  // @@protoc_insertion_point(field_mutable_list:frrpc.route.RouteNetInfo.target_sockets)
  return &target_sockets_;
}

// int32 source_socket = 4;
inline void RouteNetInfo::clear_source_socket() {
  source_socket_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RouteNetInfo::source_socket() const {
  // @@protoc_insertion_point(field_get:frrpc.route.RouteNetInfo.source_socket)
  return source_socket_;
}
inline void RouteNetInfo::set_source_socket(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  source_socket_ = value;
  // @@protoc_insertion_point(field_set:frrpc.route.RouteNetInfo.source_socket)
}

// -------------------------------------------------------------------

// RouteCmdRequest

// .frrpc.route.eRouteCmd cmd = 1;
inline void RouteCmdRequest::clear_cmd() {
  cmd_ = 0;
}
inline ::frrpc::route::eRouteCmd RouteCmdRequest::cmd() const {
  // @@protoc_insertion_point(field_get:frrpc.route.RouteCmdRequest.cmd)
  return static_cast< ::frrpc::route::eRouteCmd >(cmd_);
}
inline void RouteCmdRequest::set_cmd(::frrpc::route::eRouteCmd value) {
  
  cmd_ = value;
  // @@protoc_insertion_point(field_set:frrpc.route.RouteCmdRequest.cmd)
}

// bytes request_binary = 2;
inline void RouteCmdRequest::clear_request_binary() {
  request_binary_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RouteCmdRequest::request_binary() const {
  // @@protoc_insertion_point(field_get:frrpc.route.RouteCmdRequest.request_binary)
  return request_binary_.GetNoArena();
}
inline void RouteCmdRequest::set_request_binary(const std::string& value) {
  
  request_binary_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:frrpc.route.RouteCmdRequest.request_binary)
}
inline void RouteCmdRequest::set_request_binary(std::string&& value) {
  
  request_binary_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:frrpc.route.RouteCmdRequest.request_binary)
}
inline void RouteCmdRequest::set_request_binary(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  request_binary_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:frrpc.route.RouteCmdRequest.request_binary)
}
inline void RouteCmdRequest::set_request_binary(const void* value, size_t size) {
  
  request_binary_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:frrpc.route.RouteCmdRequest.request_binary)
}
inline std::string* RouteCmdRequest::mutable_request_binary() {
  
  // @@protoc_insertion_point(field_mutable:frrpc.route.RouteCmdRequest.request_binary)
  return request_binary_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RouteCmdRequest::release_request_binary() {
  // @@protoc_insertion_point(field_release:frrpc.route.RouteCmdRequest.request_binary)
  
  return request_binary_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RouteCmdRequest::set_allocated_request_binary(std::string* request_binary) {
  if (request_binary != nullptr) {
    
  } else {
    
  }
  request_binary_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_binary);
  // @@protoc_insertion_point(field_set_allocated:frrpc.route.RouteCmdRequest.request_binary)
}

// -------------------------------------------------------------------

// RouteCmdResponse

// .frrpc.route.eRouteCmd cmd = 1;
inline void RouteCmdResponse::clear_cmd() {
  cmd_ = 0;
}
inline ::frrpc::route::eRouteCmd RouteCmdResponse::cmd() const {
  // @@protoc_insertion_point(field_get:frrpc.route.RouteCmdResponse.cmd)
  return static_cast< ::frrpc::route::eRouteCmd >(cmd_);
}
inline void RouteCmdResponse::set_cmd(::frrpc::route::eRouteCmd value) {
  
  cmd_ = value;
  // @@protoc_insertion_point(field_set:frrpc.route.RouteCmdResponse.cmd)
}

// -------------------------------------------------------------------

// ChannelServiceRegister

// string service_name = 1;
inline void ChannelServiceRegister::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ChannelServiceRegister::service_name() const {
  // @@protoc_insertion_point(field_get:frrpc.route.ChannelServiceRegister.service_name)
  return service_name_.GetNoArena();
}
inline void ChannelServiceRegister::set_service_name(const std::string& value) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:frrpc.route.ChannelServiceRegister.service_name)
}
inline void ChannelServiceRegister::set_service_name(std::string&& value) {
  
  service_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:frrpc.route.ChannelServiceRegister.service_name)
}
inline void ChannelServiceRegister::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:frrpc.route.ChannelServiceRegister.service_name)
}
inline void ChannelServiceRegister::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:frrpc.route.ChannelServiceRegister.service_name)
}
inline std::string* ChannelServiceRegister::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:frrpc.route.ChannelServiceRegister.service_name)
  return service_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChannelServiceRegister::release_service_name() {
  // @@protoc_insertion_point(field_release:frrpc.route.ChannelServiceRegister.service_name)
  
  return service_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelServiceRegister::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:frrpc.route.ChannelServiceRegister.service_name)
}

// string service_addr = 2;
inline void ChannelServiceRegister::clear_service_addr() {
  service_addr_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ChannelServiceRegister::service_addr() const {
  // @@protoc_insertion_point(field_get:frrpc.route.ChannelServiceRegister.service_addr)
  return service_addr_.GetNoArena();
}
inline void ChannelServiceRegister::set_service_addr(const std::string& value) {
  
  service_addr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:frrpc.route.ChannelServiceRegister.service_addr)
}
inline void ChannelServiceRegister::set_service_addr(std::string&& value) {
  
  service_addr_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:frrpc.route.ChannelServiceRegister.service_addr)
}
inline void ChannelServiceRegister::set_service_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_addr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:frrpc.route.ChannelServiceRegister.service_addr)
}
inline void ChannelServiceRegister::set_service_addr(const char* value, size_t size) {
  
  service_addr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:frrpc.route.ChannelServiceRegister.service_addr)
}
inline std::string* ChannelServiceRegister::mutable_service_addr() {
  
  // @@protoc_insertion_point(field_mutable:frrpc.route.ChannelServiceRegister.service_addr)
  return service_addr_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChannelServiceRegister::release_service_addr() {
  // @@protoc_insertion_point(field_release:frrpc.route.ChannelServiceRegister.service_addr)
  
  return service_addr_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelServiceRegister::set_allocated_service_addr(std::string* service_addr) {
  if (service_addr != nullptr) {
    
  } else {
    
  }
  service_addr_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_addr);
  // @@protoc_insertion_point(field_set_allocated:frrpc.route.ChannelServiceRegister.service_addr)
}

// -------------------------------------------------------------------

// ServerDisconnectChannel

// repeated int32 channel_socket = 1;
inline int ServerDisconnectChannel::channel_socket_size() const {
  return channel_socket_.size();
}
inline void ServerDisconnectChannel::clear_channel_socket() {
  channel_socket_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerDisconnectChannel::channel_socket(int index) const {
  // @@protoc_insertion_point(field_get:frrpc.route.ServerDisconnectChannel.channel_socket)
  return channel_socket_.Get(index);
}
inline void ServerDisconnectChannel::set_channel_socket(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  channel_socket_.Set(index, value);
  // @@protoc_insertion_point(field_set:frrpc.route.ServerDisconnectChannel.channel_socket)
}
inline void ServerDisconnectChannel::add_channel_socket(::PROTOBUF_NAMESPACE_ID::int32 value) {
  channel_socket_.Add(value);
  // @@protoc_insertion_point(field_add:frrpc.route.ServerDisconnectChannel.channel_socket)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ServerDisconnectChannel::channel_socket() const {
  // @@protoc_insertion_point(field_list:frrpc.route.ServerDisconnectChannel.channel_socket)
  return channel_socket_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ServerDisconnectChannel::mutable_channel_socket() {
  // @@protoc_insertion_point(field_mutable_list:frrpc.route.ServerDisconnectChannel.channel_socket)
  return &channel_socket_;
}

// -------------------------------------------------------------------

// RouteServiceInfo

// string name = 1;
inline void RouteServiceInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RouteServiceInfo::name() const {
  // @@protoc_insertion_point(field_get:frrpc.route.RouteServiceInfo.name)
  return name_.GetNoArena();
}
inline void RouteServiceInfo::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:frrpc.route.RouteServiceInfo.name)
}
inline void RouteServiceInfo::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:frrpc.route.RouteServiceInfo.name)
}
inline void RouteServiceInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:frrpc.route.RouteServiceInfo.name)
}
inline void RouteServiceInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:frrpc.route.RouteServiceInfo.name)
}
inline std::string* RouteServiceInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:frrpc.route.RouteServiceInfo.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RouteServiceInfo::release_name() {
  // @@protoc_insertion_point(field_release:frrpc.route.RouteServiceInfo.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RouteServiceInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:frrpc.route.RouteServiceInfo.name)
}

// string addr = 2;
inline void RouteServiceInfo::clear_addr() {
  addr_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RouteServiceInfo::addr() const {
  // @@protoc_insertion_point(field_get:frrpc.route.RouteServiceInfo.addr)
  return addr_.GetNoArena();
}
inline void RouteServiceInfo::set_addr(const std::string& value) {
  
  addr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:frrpc.route.RouteServiceInfo.addr)
}
inline void RouteServiceInfo::set_addr(std::string&& value) {
  
  addr_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:frrpc.route.RouteServiceInfo.addr)
}
inline void RouteServiceInfo::set_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  addr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:frrpc.route.RouteServiceInfo.addr)
}
inline void RouteServiceInfo::set_addr(const char* value, size_t size) {
  
  addr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:frrpc.route.RouteServiceInfo.addr)
}
inline std::string* RouteServiceInfo::mutable_addr() {
  
  // @@protoc_insertion_point(field_mutable:frrpc.route.RouteServiceInfo.addr)
  return addr_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RouteServiceInfo::release_addr() {
  // @@protoc_insertion_point(field_release:frrpc.route.RouteServiceInfo.addr)
  
  return addr_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RouteServiceInfo::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:frrpc.route.RouteServiceInfo.addr)
}

// -------------------------------------------------------------------

// RouteNotify

// .frrpc.route.eRouteNotifyType type = 1;
inline void RouteNotify::clear_type() {
  type_ = 0;
}
inline ::frrpc::route::eRouteNotifyType RouteNotify::type() const {
  // @@protoc_insertion_point(field_get:frrpc.route.RouteNotify.type)
  return static_cast< ::frrpc::route::eRouteNotifyType >(type_);
}
inline void RouteNotify::set_type(::frrpc::route::eRouteNotifyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:frrpc.route.RouteNotify.type)
}

// bytes data = 2;
inline void RouteNotify::clear_data() {
  data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RouteNotify::data() const {
  // @@protoc_insertion_point(field_get:frrpc.route.RouteNotify.data)
  return data_.GetNoArena();
}
inline void RouteNotify::set_data(const std::string& value) {
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:frrpc.route.RouteNotify.data)
}
inline void RouteNotify::set_data(std::string&& value) {
  
  data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:frrpc.route.RouteNotify.data)
}
inline void RouteNotify::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:frrpc.route.RouteNotify.data)
}
inline void RouteNotify::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:frrpc.route.RouteNotify.data)
}
inline std::string* RouteNotify::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:frrpc.route.RouteNotify.data)
  return data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RouteNotify::release_data() {
  // @@protoc_insertion_point(field_release:frrpc.route.RouteNotify.data)
  
  return data_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RouteNotify::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:frrpc.route.RouteNotify.data)
}

// -------------------------------------------------------------------

// NotifyType_Disconnect

// int32 socket = 1;
inline void NotifyType_Disconnect::clear_socket() {
  socket_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NotifyType_Disconnect::socket() const {
  // @@protoc_insertion_point(field_get:frrpc.route.NotifyType_Disconnect.socket)
  return socket_;
}
inline void NotifyType_Disconnect::set_socket(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  socket_ = value;
  // @@protoc_insertion_point(field_set:frrpc.route.NotifyType_Disconnect.socket)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace route
}  // namespace frrpc

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::frrpc::route::eRouteCmd> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::frrpc::route::eRouteCmd>() {
  return ::frrpc::route::eRouteCmd_descriptor();
}
template <> struct is_proto_enum< ::frrpc::route::eRouteNotifyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::frrpc::route::eRouteNotifyType>() {
  return ::frrpc::route::eRouteNotifyType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_route_2eproto
