### 介绍
	* 这是一个和常规rpc不太一样的rpc库。
	  看过grpc和brpc后，发现在游戏场景下，常规的req-res的方式的rpc并不适用或使用场景严重受限。
	  (考虑过streaming方案，但如果用此方案，实际上和网络库的区别很小，甚至还需要多发包头)
	  仔细思考了后，发现实际上是场景不同导致的。所以，该rpc的在使用上，可能会和常规的rpc不太一样.
	* 这是一个强调易用性的rpc简易框架。
		* 该rpc目标是使用protobuf service简介的定义风格.来接收群发式消息.
	* 包含一个网关
		* 游戏内挂一个gate是非常正常的事情。因为本身定位就是一个简易的游戏rpc。
		  并且考虑到网关很可能需要了解协议结构，所以干脆提供一个简单的网关。
		* 网关是可选的，并非必须.

### network
	* 暂时用hpsocket.
	* 后续会自己做一个网络库(看hpsocket的使用情况).

* client
	* 支持最简单的同步读写
	* 增加异步的回调函数注册机制。使用option的方式来进行.
		* 在Channel添加到stub时，默认开启所有的消息的接收(但设为null,只有真正设置回调后才有效)。
		  但真实回调，需要调用对应函数，并且通过done变量生变对应的callback。此函数可变，以最后一次为准。
		  所有异步消息，需要通过调用channel.DoAsyncMsg() 来执行——通过此方式可以让用户来确定具体的执行线程。此调用支持多线程。
* server
	* 支持通过done->Run()来结束的同步回调过程.
	* 需要支持：监听，网关两种消息接受。通过需要预留扩展其他接收方式。
		* 其他扩展暂时不开率的情况下，监听和网关只能同时存在一个。
		  因为如果连网关，则不应该再存在监听.内部如果要走消息，应该通过网关转发，或以后的MQ扩展.
	* 能够指定工作线程数（以保证能够做单线程的情况）
	* 通过server-description和method-description来发送消息
		* SendFunc(method, response);	// method中包含着server-description。但具体参数以易用性为准
* common
	* 增加linux 信号量退出的功能.
* gate
	* 支持直接的消息分发：需要server先请求注册
		* server and client 需要提供对应的支持机制
	* 支持某类服务的client状态标识机制。
		* 即server可以通过特定消息，对某个gate上的某个socket进行绑定.
		  只要是此类服务的消息,都会固定转发到该server上，
		  直到server主动解绑，或该socket断开链接为止.
		* 暂时只支持server的单向绑定。
* MQ or 其他通信方式的支持
	* 在一些简单的地方预留(例如枚举，switch判断等). 但相对复杂的地方先进行预留。
	* 年前应该不会有mq的扩展。
* hpsocket当前的使用方式存在bug（当发送大块数据时）
	* 或者在基础上加锁，或者自己写一个net 在底层加锁.

